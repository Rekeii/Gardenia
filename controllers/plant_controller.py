from models.plant_model import PlantModel, PlantType, PlantHealth
from models.mongodb_client import MongoDBClient
from bson import ObjectId
import os
from typing import Optional
from datetime import datetime 
import asyncio  # New addition: Importing asyncio

class PlantController:
    def __init__(self):
        self.mongodb_client = MongoDBClient()
        self.plants_collection = self.mongodb_client.plants_collection

    async def add_plant(self, plant_data: dict) -> tuple[bool, str]:
        """Adds a new plant to the database.

        Args:
            plant_data: A dictionary containing the plant's information.  This
                         dictionary should *not* include an _id.  _id is
                         generated by MongoDB.  This comes straight from the
                         view.

        Returns:
            A tuple: (True, message) if successful, (False, error_message) if not.
        """
        loop = asyncio.get_running_loop()

        # --- Input Validation and Data Conversion (Critical) ---
        try:
            # Convert string dates to datetime objects.  Crucially, handle
            # potential errors gracefully.
            try:
                planting_date = datetime.strptime(plant_data['planting_date'], '%m/%d/%Y')
                estimated_harvest_date = datetime.strptime(plant_data['estimated_harvest_date'], '%m/%d/%Y')
                last_watered = datetime.strptime(plant_data['last_watered'], '%m/%d/%Y')
            except ValueError as e:
                return False, f"Invalid date format: {e}.  Please use MM/DD/YYYY."
            except KeyError as e:
                return False, f"Missing required field: {e}"
            
            #Validate Enum Entry
            try:
                plant_type_enum = PlantType(plant_data['plant_type'])  # Convert to Enum
                health_status_enum = PlantHealth(plant_data.get('health_status', 'healthy'))
                
            except ValueError as e:
                 return False, f"Incorrect Plant Type or Health Status Input: {e}"

            # Create a PlantModel instance.  Do the conversion *here*, not in the view.
            plant_model = PlantModel(
                name=plant_data['name'],
                plant_type=plant_type_enum,  # Use the Enum
                planting_date=planting_date,
                estimated_harvest_date=estimated_harvest_date,
                location=plant_data.get('location', 'Unknown'), # Good practice to handle optional missing keys
                health_status=health_status_enum,  # Use the Enum, get is good for optional
                last_watered=last_watered,
                observations=[plant_data['observations']] if plant_data['observations'] else [], #Handle Potentially non list
                _id=None  # Don't pass an _id; let MongoDB create it.
            )

            plant_dict = plant_model.to_dict()
            #Remove the iso format converting, since we changed to datetime
            plant_dict["planting_date"] = planting_date
            plant_dict["estimated_harvest_date"] = estimated_harvest_date
            plant_dict["last_watered"] = last_watered
            print(plant_dict)

        except Exception as e:  # Catch any other validation errors
            return False, f"Data validation error: {e}"

        # --- Database Interaction ---
        try:
            result = await loop.run_in_executor(None, self.plants_collection.insert_one, plant_dict)
            return True, f"Plant '{plant_data['name']}' added successfully. ID: {result.inserted_id}"
        except Exception as e:
            return False, f"Database error: {str(e)}"

    async def update_plant_health(self, plant_id: str, new_health_status: PlantHealth) -> tuple[bool, str]:
        loop = asyncio.get_running_loop()
        try:
            # Use run_in_executor
            result = await loop.run_in_executor(
                None,
                self.plants_collection.update_one,
                {'_id': ObjectId(plant_id)},
                {'$set': {'health_status': new_health_status.value}}
            )
            if result.modified_count == 1:
                return True, f"Plant health updated to '{new_health_status.value}'"
            else:
                return False, "Plant not found or health not updated."
        except Exception as e:
            return False, str(e)

    async def log_observation(self, plant_id: str, observation: str) -> tuple[bool, str]:
        loop = asyncio.get_running_loop()
        try:
            # Use run_in_executor
            result = await loop.run_in_executor(
                None,
                self.plants_collection.update_one,
                {'_id': ObjectId(plant_id)},
                {'$push': {'observations': observation}}
            )
            if result.modified_count == 1:
                return True, "Observation logged successfully."
            else:
                return False, "Plant not found or observation not logged."
        except Exception as e:
            return False, str(e)

    async def get_plants(self) -> list[PlantModel]:
        loop = asyncio.get_running_loop()  # Get the current event loop
        try:
            plants = []
            # Use run_in_executor to run the find() operation in a thread
            cursor = await loop.run_in_executor(None, self.plants_collection.find)
             # Iterate over the cursor synchronously
            for plant_data in cursor:
                plants.append(PlantModel.from_dict(plant_data))
            return plants
        except Exception as e:
            print(f"Error fetching plants: {e}")
            return []
    async def get_plant_by_id(self, plant_id: str) -> Optional[PlantModel]:
        loop = asyncio.get_running_loop()
        try:
           plant = await loop.run_in_executor(None, self.plants_collection.find_one, {'_id': ObjectId(plant_id)})
           if plant:
               return PlantModel.from_dict(plant)
           return None
        except Exception as e:
           print(f"Error fetching plants by ID: {e}")

    async def close_connection(self) -> None: # make close_connection also async
        loop = asyncio.get_running_loop()
        # Use run_in_executor because close() is synchronous
        await loop.run_in_executor(None, self.mongodb_client.close_connection)
